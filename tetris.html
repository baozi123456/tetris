<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片版俄罗斯方块</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .game-board {
            border: 3px solid #4a4a8a;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .game-info {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-width: 200px;
        }

        .score-box {
            font-size: 18px;
        }

        .score-box span {
            color: #4cc9f0;
            font-size: 24px;
            font-weight: bold;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: #4361ee;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #3a0ca3;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        .game-over h2 {
            color: #f72585;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .key-info {
            font-size: 14px;
            color: #ccc;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameBoard" class="game-board" width="300" height="600"></canvas>
        <div class="game-info">
            <div class="score-box">
                得分: <span id="score">0</span>
            </div>
            <div class="controls">
                <button class="btn" id="startBtn">开始游戏</button>
                <button class="btn" id="pauseBtn">暂停游戏</button>
                <button class="btn" id="resetBtn">重置游戏</button>
            </div>
            <div class="key-info">
                操作说明:<br>
                ← 左移 | → 右移 | ↓ 下移 | ↑ 旋转
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>游戏结束</h2>
        <p>最终得分: <span id="finalScore">0</span></p>
        <button class="btn" id="restartBtn">重新开始</button>
    </div>

    <script>
        // 游戏常量
        const ROW = 20;          // 行数
        const COL = 10;          // 列数
        const BLOCK_SIZE = 30;   // 方块大小
        
        // 1. 图片路径配置（替换成你的图片地址）
        // 方式1：本地图片（和html文件同目录）
        const BLOCK_IMAGES = [
            null,                // 索引0不用
            'i_block.png',       // I型
            'j_block.png',       // J型
            'l_block.png',       // L型
            'o_block.png',       // O型
            's_block.png',       // S型
            't_block.png',       // T型
            'z_block.png'        // Z型
        ];
        // 方式2：在线图片（示例，可替换成你的图床链接）
        // const BLOCK_IMAGES = [
        //     null,
        //     'https://example.com/i_block.png',
        //     'https://example.com/j_block.png',
        //     'https://example.com/l_block.png',
        //     'https://example.com/o_block.png',
        //     'https://example.com/s_block.png',
        //     'https://example.com/t_block.png',
        //     'https://example.com/z_block.png'
        // ];

        // 图片对象缓存（预加载用）
        const imageCache = {};
        // 标记所有图片是否加载完成
        let imagesLoaded = false;

        // 2. 预加载所有方块图片
        function preloadImages() {
            let loadedCount = 0;
            const totalImages = BLOCK_IMAGES.length - 1; // 排除索引0

            // 遍历加载图片
            for (let i = 1; i < BLOCK_IMAGES.length; i++) {
                const img = new Image();
                img.src = BLOCK_IMAGES[i];
                // 图片加载成功
                img.onload = () => {
                    imageCache[i] = img;
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        imagesLoaded = true;
                        console.log('所有方块图片加载完成！');
                    }
                };
                // 图片加载失败（降级为纯色）
                img.onerror = () => {
                    console.error(`加载图片失败: ${BLOCK_IMAGES[i]}，将使用纯色替代`);
                    imageCache[i] = null; // 标记为失败，后续用纯色
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        imagesLoaded = true;
                    }
                };
            }
        }

        // 备用颜色（图片加载失败时使用）
        const FALLBACK_COLORS = [
            null,
            '#f72585', '#4361ee', '#4cc9f0', '#3a0ca3', '#7209b7', '#b5179e', '#560bad'
        ];

        // 方块形状定义
        const SHAPES = [
            [],
            [[0, 0], [1, 0], [2, 0], [3, 0]], // I型
            [[0, 0], [0, 1], [1, 1], [2, 1]], // J型
            [[2, 0], [0, 1], [1, 1], [2, 1]], // L型
            [[0, 0], [1, 0], [0, 1], [1, 1]], // O型
            [[1, 0], [2, 0], [0, 1], [1, 1]], // S型
            [[1, 0], [0, 1], [1, 1], [2, 1]], // T型
            [[0, 0], [1, 0], [1, 1], [2, 1]]  // Z型
        ];

        // 游戏状态
        let canvas, ctx;
        let board = [];
        let currentPiece = null;
        let currentX, currentY;
        let score = 0;
        let gameInterval;
        let isPlaying = false;
        let isPaused = false;

        // 初始化
        function init() {
            canvas = document.getElementById('gameBoard');
            ctx = canvas.getContext('2d');
            
            // 先预加载图片
            preloadImages();
            
            resetBoard();
            bindEvents();
            drawBoard();
        }

        // 重置游戏面板
        function resetBoard() {
            board = Array(ROW).fill().map(() => Array(COL).fill(0));
            score = 0;
            document.getElementById('score').textContent = score;
            isPlaying = false;
            isPaused = false;
            
            if (gameInterval) clearInterval(gameInterval);
            document.getElementById('gameOver').style.display = 'none';
        }

        // 生成随机方块
        function generateRandomPiece() {
            const type = Math.floor(Math.random() * 7) + 1;
            const shape = SHAPES[type];
            return { type, shape };
        }

        // 生成新方块
        function newPiece() {
            // 图片未加载完成时，等待
            if (!imagesLoaded) {
                setTimeout(newPiece, 100);
                return;
            }
            
            const piece = generateRandomPiece();
            currentPiece = piece;
            currentX = Math.floor(COL / 2) - Math.ceil(piece.shape[0].length / 2);
            currentY = 0;

            if (!isValidMove(currentX, currentY, currentPiece.shape)) {
                gameOver();
            }
        }

        // 检查移动是否有效
        function isValidMove(x, y, shape) {
            for (let i = 0; i < shape.length; i++) {
                const dx = shape[i][0];
                const dy = shape[i][1];
                const newX = x + dx;
                const newY = y + dy;

                if (newX < 0 || newX >= COL || newY >= ROW) {
                    return false;
                }
                if (newY >= 0 && board[newY][newX] !== 0) {
                    return false;
                }
            }
            return true;
        }

        // 固定方块到面板
        function fixPiece() {
            for (let i = 0; i < currentPiece.shape.length; i++) {
                const dx = shape[i][0];
                const dy = shape[i][1];
                const x = currentX + dx;
                const y = currentY + dy;
                
                if (y >= 0) {
                    board[y][x] = currentPiece.type;
                }
            }

            checkLines();
            newPiece();
        }

        // 检查消除行
        function checkLines() {
            let linesCleared = 0;
            
            for (let y = ROW - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesCleared++;
                    
                    for (let ny = y; ny > 0; ny--) {
                        board[ny] = [...board[ny - 1]];
                    }
                    board[0] = Array(COL).fill(0);
                    y++;
                }
            }

            if (linesCleared > 0) {
                score += linesCleared * 100 * linesCleared;
                document.getElementById('score').textContent = score;
            }
        }

        // 旋转方块（修复版）
        function rotatePiece() {
            if (!currentPiece || currentPiece.type === 4) return;
            
            const rotatedShape = currentPiece.shape.map(([x, y]) => [y, -x]);
            
            if (isValidMove(currentX, currentY, rotatedShape)) {
                currentPiece.shape = rotatedShape;
                drawBoard();
                drawPiece();
                return;
            }
            
            let offsetX = 0;
            const shapeXs = rotatedShape.map(([dx]) => currentX + dx);
            const minX = Math.min(...shapeXs);
            const maxX = Math.max(...shapeXs);
            
            if (minX < 0) {
                offsetX = -minX;
            } else if (maxX >= COL) {
                offsetX = COL - 1 - maxX;
            }
            
            if (isValidMove(currentX + offsetX, currentY, rotatedShape)) {
                currentX += offsetX;
                currentPiece.shape = rotatedShape;
                drawBoard();
                drawPiece();
                return;
            }
            
            if (isValidMove(currentX, currentY - 1, rotatedShape)) {
                currentY -= 1;
                currentPiece.shape = rotatedShape;
                drawBoard();
                drawPiece();
            }
        }

        // 移动方块
        function movePiece(dx, dy) {
            if (!currentPiece || isPaused || !imagesLoaded) return;
            
            const newX = currentX + dx;
            const newY = currentY + dy;
            
            if (isValidMove(newX, newY, currentPiece.shape)) {
                currentX = newX;
                currentY = newY;
                drawBoard();
                drawPiece();
                return true;
            } else if (dy > 0) {
                fixPiece();
                drawBoard();
                return false;
            }
            
            return false;
        }

        // 下落方块
        function dropPiece() {
            if (!isPlaying || isPaused || !imagesLoaded) return;
            movePiece(0, 1);
        }

        // 3. 重写绘制方块函数（图片版）
        function drawBlock(x, y, type) {
            // 先绘制边框（保留网格效果）
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);

            // 图片加载成功则绘制图片
            if (imageCache[type]) {
                ctx.drawImage(
                    imageCache[type],
                    x,          // 画布X坐标
                    y,          // 画布Y坐标
                    BLOCK_SIZE, // 绘制宽度
                    BLOCK_SIZE  // 绘制高度
                );
            } else {
                // 图片加载失败，降级为纯色
                ctx.fillStyle = FALLBACK_COLORS[type];
                ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
                // 高光效果
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(x + 2, y + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
            }
        }

        // 绘制游戏面板
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格线
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // 绘制已有方块
            for (let y = 0; y < ROW; y++) {
                for (let x = 0; x < COL; x++) {
                    const type = board[y][x];
                    if (type !== 0) {
                        drawBlock(x * BLOCK_SIZE, y * BLOCK_SIZE, type);
                    }
                    // 绘制网格线
                    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
        }

        // 绘制当前方块
        function drawPiece() {
            if (!currentPiece || !imagesLoaded) return;
            
            const shape = currentPiece.shape;
            const type = currentPiece.type;
            
            for (let i = 0; i < shape.length; i++) {
                const dx = shape[i][0];
                const dy = shape[i][1];
                const x = (currentX + dx) * BLOCK_SIZE;
                const y = (currentY + dy) * BLOCK_SIZE;
                
                if (currentY + dy >= 0) {
                    drawBlock(x, y, type);
                }
            }
        }

        // 游戏结束
        function gameOver() {
            isPlaying = false;
            clearInterval(gameInterval);
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        // 开始游戏
        function startGame() {
            if (isPlaying && !isPaused) return;
            // 图片未加载完成时，提示等待
            if (!imagesLoaded) {
                alert('图片正在加载中，请稍等！');
                return;
            }
            
            if (!isPlaying) {
                resetBoard();
                newPiece();
                isPlaying = true;
            } else if (isPaused) {
                isPaused = false;
            }
            
            gameInterval = setInterval(dropPiece, 500);
            drawBoard();
            drawPiece();
        }

        // 暂停游戏
        function pauseGame() {
            if (!isPlaying) return;
            
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(gameInterval);
            } else {
                gameInterval = setInterval(dropPiece, 500);
            }
        }

        // 绑定事件
        function bindEvents() {
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('pauseBtn').addEventListener('click', pauseGame);
            document.getElementById('resetBtn').addEventListener('click', () => {
                resetBoard();
                drawBoard();
            });
            document.getElementById('restartBtn').addEventListener('click', () => {
                startGame();
            });

            document.addEventListener('keydown', (e) => {
                if (!isPlaying || isPaused || !imagesLoaded) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        movePiece(1, 0);
                        break;
                    case 'ArrowDown':
                        movePiece(0, 1);
                        break;
                    case 'ArrowUp':
                        rotatePiece();
                        break;
                }
            });
        }

        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>
